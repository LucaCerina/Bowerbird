'''
Martijn Simon Soen Liong Oei, January 12021 H.E.

This program visualises the agglomerative hierarchical clustering results generated by 'AHCCompute'.
Amongst other things, it plots the evolution of outcome metrics through the iterations. Use this to determine a number of clusters to stop clustering at.
'''

from matplotlib import cm, colorbar, gridspec, pyplot
from mpl_toolkits.axes_grid1 import make_axes_locatable
from scipy.cluster import hierarchy
import AHCFunctions, numpy, os
import matplotlib
matplotlib.rcParams["text.usetex"] = True


def AHCResultsVisualisation(directoryData,                                        # path to the main data    directory
                            directoryFigures,                                     # path to the main figures directory
                            dataSetName,                                          # name of the data set (a folder with this name should exist in 'directoryData')
                            linkageType,                                          # determines the results to show
                            numberOfClustersHighest,                              # highest cluster number in progression plots
                            numberOfClustersLowest,                               # lowest  cluster number in progression plots (and number in single-cluster plots)
                            dimensionsUsed,                                       # names   of the dimensions
                            listGroupNames,                                       # names   of the dimension groups
                            listGroupIndices,                                     # indices of the dimension groups
                            projectName                            = "",          # name of the AHC project
                            colourMapSilhouettesAll                = cm.RdBu,
                            silhouetteColourMin                    = -0.45,       # silhouette value corresponding to left  extreme of colour map
                            silhouetteColourMax                    = 0.45,        # silhouette value corresponding to right extreme of colour map
                            radius                                 = 0.45,        # silhouette value radius shown
                            colourMapClusters                      = cm.coolwarm, # colour map for the observation matrix and the individual clusters
                            numberOfRows                           = 6,           # determines bar code height
                            numberOfColumns                        = 30,          # determines colour bar width
                            colourMapClusterMeans                  = cm.Spectral,
                            rowSpanGroups                          = 2,
                            rowSpanDimensions                      = 10,
                            rowSpanCluster                         = 5,
                            rowSpanWhiteSpace                      = 1,
                            rowSpanColourBar                       = 1,
                            colourMapDistanceInterClustersMatrices = cm.cividis_r,
                            colourBarWidth                         = "2.5%",
                            colourBarDistance                      = 0.06,
                            distanceVMin                           = 50,          # in percentage points of the maximum distance
                            fontSizeGroups                         = 12,
                            fontSizeDimensions                     = 12,
                            fontSizeClusters                       = 12,
                            plotCoefficientsOfDetermination        = True,
                            plotSilhouettesAll                     = True,
                            plotSilhouettesSummary                 = True,
                            plotIndicesDunn                        = True,
                            plotDistanceMeans                      = True,
                            plotClusters                           = True,
                            plotClusterMeans                       = True,
                            plotDistanceInterClustersMatrices      = True,
                            plotDendrogram                         = True):
    '''
    Visualises agglomerative hierarchical clustering results.
    '''

    colourMapClusters.set_bad(color = "white")

    # Load 'observationMatrix'.
    observationMatrix                   = numpy.load(directoryData + dataSetName + "/observationMatrix.npy")
    numberOfObservations, numberOfDimensions = observationMatrix.shape
    observationNames                    = numpy.arange(numberOfObservations)

    # Load data.
    linkageTypeCapitalised              = linkageType.capitalize()
    clusterList                         = numpy.load(directoryData + dataSetName + "/" + "AHC" + linkageTypeCapitalised + str(numberOfClustersLowest) + "ClusterList"    + ".npy", allow_pickle = True)
    silhouettesAll                      = numpy.load(directoryData + dataSetName + "/" + "AHC" + linkageTypeCapitalised + str(numberOfClustersLowest) + "SilhouettesAll" + ".npy")
    distanceInterClustersMatrixComplete = numpy.load(directoryData + dataSetName + "/" + "AHC" + linkageTypeCapitalised + str(numberOfClustersLowest) + "DistanceInterClustersMatrixComplete" + ".npy")
    distanceInterClustersMatrixAverage  = numpy.load(directoryData + dataSetName + "/" + "AHC" + linkageTypeCapitalised + str(numberOfClustersLowest) + "DistanceInterClustersMatrixAverage" + ".npy")
    distanceInterClustersMatrixSingle   = numpy.load(directoryData + dataSetName + "/" + "AHC" + linkageTypeCapitalised + str(numberOfClustersLowest) + "DistanceInterClustersMatrixSingle" + ".npy")

    numberOfData                        = numberOfClustersHighest - numberOfClustersLowest + 1 # in 1
    distanceInterClustersMeansComplete  = numpy.empty(numberOfData)
    distanceInterClustersMeansAverage   = numpy.empty(numberOfData)
    distanceInterClustersMeansSingle    = numpy.empty(numberOfData)
    distanceIntraClustersMeans          = numpy.empty(numberOfData)
    silhouetteMeans                     = numpy.empty(numberOfData)
    silhouetteSDs                       = numpy.empty(numberOfData)
    indicesDunnComplete                 = numpy.empty(numberOfData)
    indicesDunnAverage                  = numpy.empty(numberOfData)
    indicesDunnSingle                   = numpy.empty(numberOfData)
    coefficientsOfDetermination         = numpy.empty(numberOfData) # in 1

    for numberOfClusters, i in zip(range(numberOfClustersLowest, numberOfClustersHighest + 1)[::-1], range(numberOfData)):
        metricsSingleNumber                   = numpy.load(directoryData + dataSetName + "/" + "AHC" + linkageTypeCapitalised + str(numberOfClusters) + "MetricsSingleNumber" + ".npy")
        distanceInterClustersMeansComplete[i] = metricsSingleNumber[0]
        distanceInterClustersMeansAverage [i] = metricsSingleNumber[1]
        distanceInterClustersMeansSingle  [i] = metricsSingleNumber[2]
        distanceIntraClustersMeans        [i] = metricsSingleNumber[3]
        silhouetteMeans                   [i] = metricsSingleNumber[4]
        silhouetteSDs                     [i] = metricsSingleNumber[5]
        indicesDunnComplete               [i] = metricsSingleNumber[10]
        indicesDunnAverage                [i] = metricsSingleNumber[11]
        indicesDunnSingle                 [i] = metricsSingleNumber[12]
        coefficientsOfDetermination       [i] = metricsSingleNumber[13]

    rangeClusterNumberMetrics           = numpy.arange(numberOfClustersLowest, numberOfClustersHighest + 1)[ : : -1]


    if (plotClusters or plotClusterMeans):
        clusterSizeList             = []
        clusterObservationNamesList = []
        clusterMatrixPlotList       = []
        clusterMeansList            = []

        for i in range(numberOfClustersLowest):
            clusterObservationIndices = clusterList[i]
            clusterSize               = len(clusterObservationIndices)
            clusterObservationNames   = observationNames[clusterObservationIndices]
            clusterMatrix             = observationMatrix[clusterObservationIndices]
            clusterMatrixPlot         = clusterMatrix.astype(numpy.float64)
            clusterMatrixPlot[(clusterMatrix == -1)] = numpy.nan
            clusterMeans              = numpy.nanmean(clusterMatrixPlot, axis = 0)

            # Save quantities that can be used in plots later.
            clusterSizeList.append(clusterSize)
            clusterObservationNamesList.append(clusterObservationNames)
            clusterMatrixPlotList.append(clusterMatrixPlot)
            clusterMeansList.append(clusterMeans)


    # Generate the directory for the figures, if it does not exist yet.
    if (not os.path.exists(directoryFigures + dataSetName + "/")):
        os.makedirs(directoryFigures + dataSetName + "/")



    if (plotCoefficientsOfDetermination):
        pyplot.figure(figsize = (12, 6))
        pyplot.scatter(rangeClusterNumberMetrics, coefficientsOfDetermination * 100, s = 4, c = "crimson")
        pyplot.plot(rangeClusterNumberMetrics, coefficientsOfDetermination * 100, ls = "--", c = "crimson", alpha = .5)
        pyplot.gca().invert_xaxis()
        pyplot.grid(ls = "--", alpha = .2)
        pyplot.xticks(rangeClusterNumberMetrics)
        pyplot.xlim(rangeClusterNumberMetrics[0] + .1, rangeClusterNumberMetrics[-1] - .1)
        pyplot.xlabel("number of clusters (1)")
        pyplot.ylabel(r"fraction of explained variance (\%)")
        pyplot.title(r"goodness of fit $\vert$ coefficient of determination $R^2$")
        pyplot.tight_layout()
        pyplot.savefig(directoryFigures + dataSetName + "/" + "AHC" + linkageTypeCapitalised + str(numberOfClustersLowest) + "CoefficientsOfDetermination" + ".pdf")
        pyplot.close()



    if (plotSilhouettesAll):

        pyplot.figure(figsize = (12, 4))
        for indexCluster in range(numberOfClustersLowest):
            clusterObservationIndices = clusterList[indexCluster]
            clusterSize               = len(clusterObservationIndices)
            clusterSilhouettesSorted  = numpy.sort(silhouettesAll[clusterObservationIndices])
            clusterSilhouetteMean     = numpy.mean(clusterSilhouettesSorted)

            axesCluster               = pyplot.subplot2grid((1, numberOfClustersLowest), (0, indexCluster), rowspan = 1, colspan = 1)

            axesCluster.bar(range(clusterSize), clusterSilhouettesSorted, width = 1, color = colourMapSilhouettesAll(numpy.clip((clusterSilhouettesSorted - silhouetteColourMin) / (silhouetteColourMax - silhouetteColourMin), 0, 1)))
            axesCluster.set_xlim(-0.5, clusterSize - 0.5)
            axesCluster.set_ylim(-radius, radius)
            axesCluster.set_xticks([])

            if (indexCluster == 0):
                axesCluster.set_ylabel("silhouette (1)", fontsize = "large")
                axesCluster.yaxis.set_tick_params(labelsize = "large")
            else:
                axesCluster.set_yticklabels([])

            axesCluster.set_title("cluster " + str(indexCluster + 1) + "\n" + "$\mu = " + str(numpy.round(clusterSilhouetteMean, 2)) + "$", fontsize = "large")
            #axesCluster.set_title(r"\textbf{" + str(indexCluster + 1) + r"}:" + "\n" + r"$N = " + str(clusterSize) + r"$ $\vert$ $\mu = " + str(numpy.round(clusterSilhouetteMean, 2)) + "$")
            axesCluster.grid(ls = "--", alpha = .3)
        #pyplot.suptitle(r"\textbf{all clusters}: $N = " + str(numberOfObservations) + r"$ $\vert$ $\mu = " + str(numpy.round(numpy.mean(silhouettesAll), 2)) + "$")
        #pyplot.subplots_adjust(left = 0.07, right = .99, bottom = .01, top = .85, wspace = 0)
        #pyplot.yticks(fontsize = "large")
        pyplot.subplots_adjust(left = 0.07, right = .99, bottom = .01, top = .88, wspace = 0)
        pyplot.savefig(directoryFigures + dataSetName + "/" + "AHC" + linkageTypeCapitalised + str(numberOfClustersLowest) + "SilhouettesAll" + ".pdf")
        pyplot.close()



    if (plotSilhouettesSummary):
        pyplot.figure(figsize = (12, 6))
        pyplot.scatter(rangeClusterNumberMetrics, silhouetteMeans, s = 4, label = r"$\mu$", c = "orangered")
        pyplot.plot(   rangeClusterNumberMetrics, silhouetteMeans, ls = "--", alpha = .5, c = "orangered")
        pyplot.axhline(y = 0, c = "gray")

        #pyplot.fill_between(rangeClusterNumberMetrics, silhouetteMeans - 2 * silhouetteSDs, silhouetteMeans + 2 * silhouetteSDs, alpha = .2, color = "orangered", lw = 0)
        pyplot.fill_between(rangeClusterNumberMetrics, silhouetteMeans - 1 * silhouetteSDs, silhouetteMeans + 1 * silhouetteSDs, alpha = .2, color = "orangered", lw = 0, label = r"$\pm1\ \sigma$")

        pyplot.grid(ls = "--", alpha = .25)
        pyplot.gca().invert_xaxis()

        pyplot.xticks(rangeClusterNumberMetrics)
        pyplot.xlim(numberOfClustersHighest + 0.1, numberOfClustersLowest - 0.1)
        #pyplot.ylim(-1, 1)

        pyplot.xlabel("number of clusters (1)")
        pyplot.ylabel("silhouette (1)")
        pyplot.legend(loc = "upper left")
        pyplot.title(r"silhouette (mean and standard deviation) during agglomerative hierarchical clustering $\vert$ " + r"\textbf{" + linkageType + r"}" + " linkage")
        pyplot.subplots_adjust(left = 0.07, right = 0.98, bottom = 0.08, top = 0.92)
        pyplot.savefig(directoryFigures + dataSetName + "/" + "AHC" + linkageTypeCapitalised + str(numberOfClustersLowest) + "ProgressionSilhouettes" + ".pdf")
        pyplot.close()



    if (plotIndicesDunn):
        pyplot.figure(figsize = (12, 6))
        pyplot.scatter(rangeClusterNumberMetrics, indicesDunnComplete / indicesDunnComplete[0], label = "complete", s = 4, c = "crimson")
        pyplot.plot(   rangeClusterNumberMetrics, indicesDunnComplete / indicesDunnComplete[0], ls = "--", alpha = .5,     c = "crimson")
        pyplot.scatter(rangeClusterNumberMetrics, indicesDunnAverage  / indicesDunnAverage[0],  label = "average",  s = 4, c = "yellowgreen")
        pyplot.plot(   rangeClusterNumberMetrics, indicesDunnAverage  / indicesDunnAverage[0],  ls = "--", alpha = .5,     c = "yellowgreen")
        pyplot.scatter(rangeClusterNumberMetrics, indicesDunnSingle   / indicesDunnSingle[0],   label = "single",   s = 4, c = "navy")
        pyplot.plot(   rangeClusterNumberMetrics, indicesDunnSingle   / indicesDunnSingle[0],   ls = "--", alpha = .5,     c = "navy")

        pyplot.grid(ls = "--", alpha = .25)
        pyplot.gca().invert_xaxis()
        pyplot.xticks(rangeClusterNumberMetrics)
        pyplot.xlim(numberOfClustersHighest + 0.1, numberOfClustersLowest - 0.1)

        pyplot.xlabel("number of clusters (1)")
        pyplot.ylabel("relative Dunn's index (1)")

        pyplot.legend(loc = "upper left")

        pyplot.title(r"Dunn's indices during agglomerative hierarchical clustering $\vert$ " + r"\textbf{" + linkageType + r"}" + " linkage")
        pyplot.subplots_adjust(left = 0.07, right = 0.98, bottom = 0.08, top = 0.92)
        pyplot.savefig(directoryFigures + dataSetName + "/" + "AHC" + linkageTypeCapitalised + str(numberOfClustersLowest) + "ProgressionDunnsIndices" + ".pdf")
        pyplot.close()



    if (plotDistanceMeans):
        pyplot.figure(figsize = (12, 6))
        gridspec.GridSpec(10, 1)
        axesMeans          = pyplot.subplot2grid((10, 1), (0, 0), rowspan = 7, colspan = 1)
        axesRatio          = pyplot.subplot2grid((10, 1), (7, 0), rowspan = 3, colspan = 1)

        ratioComplete      = distanceInterClustersMeansComplete / distanceIntraClustersMeans
        ratioAverage       = distanceInterClustersMeansAverage  / distanceIntraClustersMeans
        ratioSingle        = distanceInterClustersMeansSingle   / distanceIntraClustersMeans

        axesMeans.scatter(rangeClusterNumberMetrics, distanceInterClustersMeansComplete, s = 4, label = "inter-cluster mean (complete)", c = "crimson")
        axesMeans.plot(   rangeClusterNumberMetrics, distanceInterClustersMeansComplete, ls = "--", alpha = .5, c = "crimson")
        axesMeans.scatter(rangeClusterNumberMetrics, distanceInterClustersMeansAverage,  s = 4, label = "inter-cluster mean (average)", c = "orangered")
        axesMeans.plot(   rangeClusterNumberMetrics, distanceInterClustersMeansAverage,  ls = "--", alpha = .5, c = "orangered")
        axesMeans.scatter(rangeClusterNumberMetrics, distanceInterClustersMeansSingle,   s = 4, label = "inter-cluster mean (single)", c = "goldenrod")
        axesMeans.plot(   rangeClusterNumberMetrics, distanceInterClustersMeansSingle,   ls = "--", alpha = .5, c = "goldenrod")

        axesMeans.scatter(rangeClusterNumberMetrics, distanceIntraClustersMeans, s = 4, label = "intra-cluster mean", c = "yellowgreen")
        axesMeans.plot(   rangeClusterNumberMetrics, distanceIntraClustersMeans, ls = "--", alpha = .5, c = "yellowgreen")

        axesRatio.scatter(rangeClusterNumberMetrics, ratioComplete, s = 4, label = "inter- over intra-cluster mean (complete)", c = "mediumseagreen")
        axesRatio.plot(   rangeClusterNumberMetrics, ratioComplete, ls = "--", alpha = .5, c = "mediumseagreen")
        axesRatio.scatter(rangeClusterNumberMetrics, ratioAverage, s = 4, label = "inter- over intra-cluster mean (average)", c = "cornflowerblue")
        axesRatio.plot(   rangeClusterNumberMetrics, ratioAverage, ls = "--", alpha = .5, c = "cornflowerblue")
        axesRatio.scatter(rangeClusterNumberMetrics, ratioSingle, s = 4, label = "inter- over intra-cluster mean (single)", c = "navy")
        axesRatio.plot(   rangeClusterNumberMetrics, ratioSingle, ls = "--", alpha = .5, c = "navy")

        axesMeans.invert_xaxis()
        axesRatio.invert_xaxis()
        axesMeans.set_xlim(numberOfClustersHighest + 0.1, numberOfClustersLowest - 0.1)
        axesRatio.set_xlim(numberOfClustersHighest + 0.1, numberOfClustersLowest - 0.1)
        axesMeans.set_xticks(rangeClusterNumberMetrics)
        axesRatio.set_xticks(rangeClusterNumberMetrics)
        axesMeans.set_xticklabels([])
        axesMeans.set_ylabel("Gower's distance (1)")
        axesRatio.set_xlabel("number of clusters (1)")
        axesRatio.set_ylabel("ratio (1)")

        axesMeans.legend(loc = "upper left")
        axesRatio.legend(loc = "upper left")
        axesMeans.set_title(r"distance measures during agglomerative hierarchical clustering $\vert$ " + r"\textbf{" + linkageType + r"}" + " linkage")
        axesMeans.grid(ls = "--", alpha = .2)
        axesRatio.grid(ls = "--", alpha = .2)

        pyplot.subplots_adjust(left = 0.07, right = 0.98, bottom = 0.08, top = 0.92)
        pyplot.savefig(directoryFigures + dataSetName + "/" + "AHC" + linkageTypeCapitalised + str(numberOfClustersLowest) + "ProgressionMeanDistances" + ".pdf")
        pyplot.close()



    # Plot the clusters that the algorithm has found.
    if (plotClusters):
        for i in range(numberOfClustersLowest):
            figure           = pyplot.figure(1)

            gridspec.GridSpec(numberOfRows, numberOfColumns)
            axesClusterWhole = pyplot.subplot2grid((numberOfRows, numberOfColumns), (0, 0), rowspan = numberOfRows - 1, colspan = numberOfColumns - 1)
            axesClusterMean  = pyplot.subplot2grid((numberOfRows, numberOfColumns), (numberOfRows - 1, 0), colspan = numberOfColumns - 1)
            axesColourBar    = pyplot.subplot2grid((numberOfRows, numberOfColumns), (0, numberOfColumns - 1), rowspan = numberOfRows - 1)

            axesClusterWhole.imshow(clusterMatrixPlotList[i], cmap = colourMapClusters, aspect = "auto", vmin = 0, vmax = 1)
            axesClusterMean.imshow(numpy.reshape(clusterMeansList[i], (1, numberOfDimensions)), cmap = colourMapClusters, aspect = "auto", vmin = 0, vmax = 1)

            colourBar        = colorbar.ColorbarBase(axesColourBar, cmap = colourMapClusters, orientation = "vertical")

            axesClusterWhole.set_xticks(numpy.arange(numberOfDimensions))
            axesClusterWhole.set_xticklabels([])
            axesClusterWhole.set_yticks(numpy.arange(clusterSizeList[i]))

            if (clusterSizeList[i] > 100): # For dense clusters, observation labels are best omitted.
                axesClusterWhole.set_yticklabels([""] * clusterSizeList[i])
            else: # For sparse clusters, observation labels are best included.
                axesClusterWhole.set_yticklabels(clusterObservationNamesList[i], fontsize = "xx-small")

            axesClusterMean.set_xticks(numpy.arange(numberOfDimensions))
            axesClusterMean.set_xticklabels(dimensionsUsed, rotation = 90)
            axesClusterMean.set_yticks([0])
            axesClusterMean.set_yticklabels(["cluster\nmean"])

            axesClusterWhole.set_ylim(-0.5, clusterSizeList[i] - 0.5)

            axesClusterWhole.set_title(projectName + "\n" + r"Gower's distance agglomerative hierarchical clustering $\vert$ " +
                                       linkageType + r" linkage $\vert$ cluster " + str(i + 1) + " of " + str(numberOfClustersLowest) + r" $\vert$ " + str(clusterSizeList[i]) + " observations")

            figure.set_size_inches(w = numberOfDimensions * .3, h = 14)
            pyplot.tight_layout()
            #pyplot.subplots_adjust(left = 0.25, right = 0.97, bottom = 0.05, top = 0.93, hspace = 0.1)
            figure.savefig(directoryFigures + dataSetName + "/" + "AHC" + linkageTypeCapitalised + str(numberOfClustersLowest) + "Cluster" + str(i + 1) + ".pdf")
            pyplot.close()


            print ("Cluster " + str(i + 1) + " of " + str(numberOfClustersLowest) + " visualised!")
            print ("clusterSize:",             clusterSizeList[i])
            print ("clusterObservationNames:", clusterObservationNamesList[i])
            print ("clusterMeans:",            clusterMeansList[i])



    if (plotClusterMeans):
        figure            = pyplot.figure(figsize = (10, 8))

        numberOfRows      = rowSpanGroups + rowSpanDimensions + numberOfClustersLowest * rowSpanCluster + rowSpanWhiteSpace + rowSpanColourBar
        numberOfColumns   = 3

        gridspec.GridSpec(numberOfRows, numberOfColumns)

        axesGroups        = pyplot.subplot2grid((numberOfRows, numberOfColumns), (0, 0), rowspan = rowSpanGroups, colspan = 3)

        groups            = numpy.zeros(numberOfDimensions)
        for i in range(len(listGroupIndices) - 1):
            groups[listGroupIndices[i] : ] += 1
            axesGroups.text((listGroupIndices[i] + listGroupIndices[i + 1] - 1) / 2, 0, listGroupNames[i], horizontalalignment = "center", verticalalignment = "center", fontsize = fontSizeGroups)

        axesGroups.imshow(numpy.reshape(groups, (1, numberOfDimensions)), cmap = colourMapClusterMeans, aspect = "auto", alpha = .75)
        axesGroups.set_xticks([])
        axesGroups.set_yticks([])

        axesDimensions = pyplot.subplot2grid((numberOfRows, numberOfColumns), (rowSpanGroups, 0), rowspan = rowSpanDimensions, colspan = 3)
        axesDimensions.imshow(numpy.reshape(groups, (1, numberOfDimensions)), cmap = colourMapClusterMeans, aspect = "auto", alpha = .5)
        axesDimensions.set_xticks([])
        axesDimensions.set_yticks([])

        for i in range(numberOfDimensions):
            axesDimensions.text(i, 0, dimensionsUsed[i], rotation = 90, horizontalalignment = "center", verticalalignment = "center", fontsize = fontSizeDimensions)

        for i in range(numberOfClustersLowest):
            axesCluster = pyplot.subplot2grid((numberOfRows, numberOfColumns), (rowSpanGroups + rowSpanDimensions + i * rowSpanCluster, 0), rowspan = rowSpanCluster, colspan = 3)

            axesCluster.imshow(numpy.reshape(clusterMeansList[i], (1, numberOfDimensions)), cmap = "coolwarm", aspect = "auto", vmin = 0, vmax = 1, alpha = 1)

            axesCluster.set_xticks([])
            axesCluster.set_yticks([0])
            axesCluster.set_yticklabels([r"\textbf{Cluster\ " + str(i + 1) + r"}" + "\n" + r"$N = " + str(clusterSizeList[i]) + r"$"], fontsize = fontSizeClusters)
            axesCluster.tick_params(axis = "y", length = 0)

        axesWhiteSpace = pyplot.subplot2grid((numberOfRows, numberOfColumns), (rowSpanGroups + rowSpanDimensions + numberOfClustersLowest * rowSpanCluster, 0), rowspan = rowSpanWhiteSpace, colspan = 3)
        axesWhiteSpace.set_visible(False)

        axesColourBar = pyplot.subplot2grid((numberOfRows, numberOfColumns), (rowSpanGroups + rowSpanDimensions + numberOfClustersLowest * rowSpanCluster + rowSpanWhiteSpace, 2), rowspan = rowSpanColourBar, colspan = 1)
        axesColourBar.imshow(numpy.reshape(numpy.linspace(0, 1, num = 1000 + 1, endpoint = True), (1, 1000 + 1)), cmap = "coolwarm", aspect = "auto", vmin = 0, vmax = 1, alpha = 1)
        axesColourBar.set_xticks([0, 1000])
        axesColourBar.set_xticklabels([0, 1])
        axesColourBar.set_yticks([])

        figure.set_size_inches(w = 11.7 * 2, h = 8.3 * 2 * .95)
        pyplot.subplots_adjust(left = .04, right = .99, bottom = .02, top = .99)#, hspace = 0)
        figure.savefig(directoryFigures + dataSetName + "/" + "AHC" + linkageTypeCapitalised + str(numberOfClustersLowest) + "ClusterMeans" + ".pdf")

        pyplot.close()



    if (plotDistanceInterClustersMatrices):
        def plotDistanceInterClustersMatrix(distanceInterClustersMatrix, linkageTypeCurrent):
            '''
            Plots all distances between the clusters present at this iteration of the algorithm.
            '''

            distanceInterClustersMax = numpy.amax(distanceInterClustersMatrix[numpy.triu_indices(numberOfClustersLowest, k = 1)])

            pyplot.figure(figsize = (7, 7))
            image                    = pyplot.imshow(distanceInterClustersMatrix / distanceInterClustersMax * 100, vmin = distanceVMin, vmax = 100, cmap = colourMapDistanceInterClustersMatrices)
            axesMain                 = pyplot.gca()
            axesColourBar            = make_axes_locatable(axesMain).append_axes("right", size = colourBarWidth, pad = colourBarDistance)
            colourBar                = pyplot.colorbar(image, cax = axesColourBar, label = r"distance relative to largest distance (\%)")

            for i in range(numberOfClustersLowest):
                for j in range(i + 1, numberOfClustersLowest):
                    axesMain.text(j, i, str(int(numpy.round(distanceInterClustersMatrix[i, j] / distanceInterClustersMax * 100))) + r"\%", c = "white", horizontalalignment = "center", verticalalignment = "center", fontsize = "x-small")

            axesMain.set_aspect("equal")
            axesMain.set_xlabel("cluster ID")
            axesMain.set_ylabel("cluster ID")
            axesMain.set_xticks(numpy.arange(numberOfClustersLowest))
            axesMain.set_yticks(numpy.arange(numberOfClustersLowest))
            axesMain.set_xticklabels(numpy.arange(numberOfClustersLowest) + 1)
            axesMain.set_yticklabels(numpy.arange(numberOfClustersLowest) + 1)
            axesMain.set_title(r"\textbf{" + linkageTypeCurrent + r" linkage distances between all pairs of " + str(numberOfClustersLowest) + " clusters}" + "\n" + r"Gower's distance metric $\vert$ " + linkageType + " linkage clustering")
            pyplot.subplots_adjust(left = 0.07, right = 0.91, bottom = 0.07, top = 0.93)
            pyplot.savefig(directoryFigures + dataSetName + "/" + "AHC" + linkageTypeCapitalised + str(numberOfClustersLowest) + "DistanceInterClustersMatrix" + linkageTypeCurrent.capitalize() + ".pdf")

            pyplot.close()

        plotDistanceInterClustersMatrix(distanceInterClustersMatrixComplete, "complete")
        plotDistanceInterClustersMatrix(distanceInterClustersMatrixAverage,  "average")
        plotDistanceInterClustersMatrix(distanceInterClustersMatrixSingle,   "single")


    if (plotDendrogram):
        # Plot dendrogram.
        dendrogramMatrix     = numpy.load(directoryData + dataSetName + "/" + "AHC" + linkageTypeCapitalised + "DendrogramMatrix.npy")
        print(dendrogramMatrix.shape)
        print(dendrogramMatrix[-6 : , : ])
        print(numpy.sort(dendrogramMatrix[-6 : , : 2].flatten()))
        dendrogramMatrixPartialOld = dendrogramMatrix[-(numberOfClustersLowest - 1) : , : ]
        dendrogramMatrixPartialNew = numpy.copy(dendrogramMatrixPartialOld)
        #indicesOld                 = numpy.sort(dendrogramMatrixPartialOld[ : , : 2].flatten())[ : numberOfClustersLowest]
        #indicesNew                 = numpy.arange(numberOfClustersLowest)
        indicesOld                 = numpy.sort(dendrogramMatrixPartialOld[ : , : 2].flatten())
        indicesNew                 = numpy.arange(2 * (numberOfClustersLowest - 1))

        #indicesNew[ : numberOfClustersLowest] = numpy.array([6, 4, 5, 2, 3, 1, 0])

        for indexOld, indexNew in zip(indicesOld, indicesNew):
            dendrogramMatrixPartialNew[dendrogramMatrixPartialOld == indexOld] = indexNew

        dendrogramMatrixPartialNew[ : , 2] = numpy.arange(numberOfClustersLowest - 1) + 1#numpy.linspace(1 / (numberOfClustersLowest - 1), 1, num = 6, endpoint = True)
        print(dendrogramMatrixPartialNew[ : , 2])
        print(indicesOld)
        print(dendrogramMatrixPartialOld)
        print(dendrogramMatrixPartialNew)
        #import sys
        #sys.exit()
        pyplot.figure(figsize = (6, 4))#(12, 8))#[6, 4, 5, 2, 3, 1, 0])
        hierarchy.dendrogram(dendrogramMatrixPartialNew, labels = ["cluster 7", "cluster 6", "cluster 4", "cluster 5", "cluster 2", "cluster 3", "cluster 1"], link_color_func = lambda k: "navy") #labels = organisationNames,labels = numpy.array([6, 4, 5, 2, 3, 1, 0]) + 1,
        pyplot.ylabel("number of clusters (1)")
        yTickLabels = (numpy.arange(numberOfClustersLowest) + 1)[::-1]
        yTickLabelStrings = []
        for yTickLabel in yTickLabels:
            yTickLabelStrings.append(str(yTickLabel))
        yTickLabelStrings[0] = ""
        pyplot.gca().set_yticklabels(yTickLabelStrings)#(numpy.arange(numberOfClustersLowest) + 1)[::-1])
        pyplot.grid(ls = "--", axis = "y", alpha = .25)
        #pyplot.ylabel("mean missing-data-corrected weighted Manhattan distance per weight (1)")
        #pyplot.title(r"\textbf{" + projectName + "}" + "\n" + r"dendrogram after agglomerative hierarchical clustering $\vert$ " + linkageType + " linkage")
        pyplot.tight_layout()
        pyplot.savefig(directoryFigures + dataSetName + "/" + "AHC" + linkageTypeCapitalised + "Dendrogram" + ".pdf")
        pyplot.close()
